
/* 
 * Quack, a simple language for beginning compiler writers
 * 
 */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree

}

%locations
  /* %define parse.trace --- can't do this and also --debug on command line */

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

/* -------------------------------------------------------
 * Semantic values: Tokens and Abstract Syntax Tree
 * -------------------------------------------------------
 */

%union {
    /* Tokens */
    int   num;
    char*  str;
    /* Abstract syntax tree values */
    AST::ASTNode* node;  // Most general class
    AST::Class* clazz;
    AST::Ident* ident;   // Identifiers are used in many places
    AST::LExpr* l_expr;
    AST::Load*  load;
    AST::Formal* formal;
    AST::Method* method;
    AST::Statement* statement;
    AST::Expr* expr;
    // Alas, looks like we need a member per sequence type
    AST::Methods* methods;
    AST::Formals* formals;
    AST::Actuals* actuals;
    AST::Block* block;
    AST::Classes* classes;
    AST::Type_Alternatives* type_alternatives;
}

/* -----------------------------------------
 * Associate non-terminals with classes in
 * the abstract syntax tree (AST)
 * ------------------------------------------
 */
%type <l_expr> l_expr
%type <expr> expr
%type <statement> statement
%type <node> pgm
%type <formal> formal
%type <classes> classes
%type <block> statements statement_block
%type <type_alternatives> type_alternatives
%type <actuals> actual_args actual_args_nonempty
%type <formals> formals formals_nonempty
%type <methods> methods
%type <method> method
%type <node>  optReturnType
%type <block>  opt_elif_parts
%type <clazz> class
%type <ident> ident optExtends

/* -------------------------------------------
 * Tokens.
 * -------------------------------------------
 */
/* Keywords (no semantic values) */
%token CLASS
%token DEF
%token EXTENDS 
%token IF ELIF ELSE
%token WHILE
%token RETURN
%token TYPECASE

 /* Multi-character punctuation (no semantic values) */
%token ATLEAST ATMOST EQUALS
%token AND OR NOT 

/* Identifiers (semantic value is the identifier name) */
%type <str> IDENT
%token IDENT

/* Literals (semantic value is the literal value) */
%token INT_LIT STRING_LIT
%type <str> STRING_LIT
%type <num> INT_LIT


/* Precedence of arithmetic operators
 * and deref
 */

%left AND OR
%left NOT
%nonassoc ATMOST '>'
%nonassoc ATLEAST '<'
%left EQUALS
%left '+' '-'
%left '*' '/'
%precedence NEG   /* Negation */ 
%left '.'         /*  because a.b.c*d is ((a.b).c)*d */
%%

/* *************************************
 * Program Structure 
 * *************************************
 */ 

/* A Quack program is a sequence of classes followed by some 
 * statements.  The statements are the main program. 
 */

pgm:	classes  statements
        { $$ = new AST::Program(*$1, *$2);
          // std::cerr << "Transmitting root to driver\n";
          *root = $$; // Transmit tree back to driver
          // std::cerr << "Transmitted root to driver\n";
        }
        ;

/* Zero or more classes */
classes:  classes class   { $$ = $1;
                            $$->append($2);
                          }
       | /* empty */      {  $$ = new AST::Classes(); }
       ;

/* Zero or more statements 
 * (although a program with zero statements is pretty boring) 
 */
statements: statements statement  { $$ = $1;
                                    $$->append($2);
                                  }
          | /* empty */           { $$ = new AST::Block(); }
          ;

/*
 * Note that we have statement terminators, not statement
 * separators, so we don't need the hackery of distinguishing 
 * between empty and non-empty lists --- the terminator 
 * (modeled here as ';' although it may not be that in our 
 * lexical structure) is part of each statement. 
 * The structure of an individual statement is defined below. 
 */ 

class: CLASS ident '(' formals ')' optExtends
      '{' statements methods '}'
    {  AST::ASTNode* constructor = new AST::Method(*$2, *$4, *$2, *$8);
       $$ = new AST::Class(*$2, *$6, *constructor, *$9);
    }
    ;

optExtends: EXTENDS ident { $$ = $2; } ;
optExtends: /* empty */ { $$ = new AST::Ident("Obj"); } ;
/* omitted 'extends' is equivalent to 'extends Obj' */

/* A list of varname: typename pairs separated by commas */ 

formals: /* empty */  { $$ = new AST::Formals(); }
    | formals_nonempty { $$ = $1; }
    ;

formals_nonempty: formals_nonempty ',' formal
               { $$ = $1;
                 $$->append($3);
               }
             | formal
               { $$ = new AST::Formals();
                 $$->append($1);
               }
             ; 

/* variable: type */
formal: ident ':' ident   { $$ = new AST::Formal(*$1, *$3); } ;

/* The class body begins with statements that form the constructor, 
 * and which implicitly declare the instance variables of the object. 
 * These are followed by method declarations.  (Now pulled up into
 * 'class' production to make it easier to treat the statements
 * as a constructor.
 */ 

/* 0 or more methods */ 
methods: methods method
       { $$ = $1;
         $$->append($2);
       }
       | /* empty */
       { $$ = new AST::Methods(); }
       ;

method: DEF ident '(' formals ')' optReturnType
       statement_block
       { $$ = new AST::Method(*$2, *$4, *$6, *$7); }
       ;

optReturnType: ':' ident  { $$ =  $2; } ;
optReturnType: /* empty */ { $$ = new AST::Ident("Nothing"); } ;

/* A block is demarcated by curly braces.   */
statement_block: '{' statements '}'
  {  $$ = $2; }
  ;

/* *************************************
 * Statements: Control structure
 * *************************************
 */ 

/* Conditional: 
 *   if x < 0 
 *     { x = x + 1; }
 *   elif x > 10
 *     { x = x - 3; }
 *   else
 *     { x = 0; }
 */ 

statement: IF expr statement_block  opt_elif_parts
	       { $$ = new AST::If(*$2, *$3, *$4); }
	     ;

opt_elif_parts:  ELIF expr statement_block  opt_elif_parts
             { $$ = new AST::Block();
               $$->append(new AST::If(*$2, *$3, *$4));
             }
             |   ELSE statement_block
             { $$ = $2; }
             | /* empty */
             { $$ = new AST::Block(); }
             ;

/* While loop: 
 *  while e { statements } 
 */ 
statement: WHILE expr statement_block
           { $$ = new AST::While(*$2, *$3); }
   ;

/* ************************************
 * Return statement
 * ************************************
 */

statement: RETURN expr ';' { $$ = new AST::Return(*$2); } ;
statement: RETURN ";"      { $$ = new AST::Return(*new AST::Ident("None")); } ;


/* *************************************
 * A bare expression evaluated for effect
 * can be a statement
 * *************************************
 */

statement: expr ';' { $$ = $1; } ;

/* *************************************
 * typecase added 2018 so that we can
 * override EQUAL inherited from Obj
 * *************************************
 */
 statement: TYPECASE expr '{' type_alternatives '}'
    { $$ = new AST::Typecase(*$2, *$4); }
    ;

 type_alternatives: /* empty */
   { $$ = new AST::Type_Alternatives(); }
   |  type_alternatives ident ':' ident statement_block
   { $$ = $1; $$->append(new AST::Type_Alternative(*$2, *$4, *$5)); }
   ;


/* *************************************
 * Statements: Assignment
 * *************************************
 */ 

/* FIXME: What to do we store for specified type
 * and for implied type?
 */
statement: l_expr '=' expr ';'
     { $$ = new AST::Assign(*$1, *$3); }
     ;

statement: l_expr ':' ident '=' expr ';'
    {
      $$ = new AST::AssignDeclare(*$1, *$5, *$3);
    }
    ;

/* l_expr: Things we can assign to, or call.
 * (Evaluate to a location; type checking determines
 * what type is compatible.)
 * Including: 
 *    Simple local variable assignments like x = expr; 
 *    Fields of the current object, this.x = expr; 
 *    Methods of any object, (3+4).PRINT, sqr.translate(1,1).translate
 */ 
l_expr: IDENT { $$ =  new AST::Ident($1); } ;

/* When we reference a field in an object, we 
 * obtain the value of the object and then get 
 * the location of the field within it.  That 
 * goes even for 'this'. 
 * (Maybe we should allow 'friendly' access
 * also for other type-compatible objects?) 
 */ 
l_expr: expr '.' ident { $$ = new AST::Dot(*$1, *$3);};

/* *************************************
 * Expressions 
 * (right-hand expressions, i.e., expressions
 *  that evaluate to values rather than locations)
 * *************************************
 */ 

/* An l_expr is also an expr; we load the value 
 * from that address.  Even though this is a unit production,
 * it corresponds to an operation (loading a value) in the
 * semantics, so we give it a node in the AST.
 */ 
expr: l_expr { $$ = new AST::Load(*$1); } ;

/* Values can also be denoted by literals */
expr: STRING_LIT { $$ = new AST::StrConst($1); }
    | INT_LIT    { $$ = new AST::IntConst($1); }
    ;

/* The binary operations.  We will use precedence 
 * rather than expanding out the expression grammar. 
 * We order by precedence and indicate associativity. 
 * 
 * Binary and unary operations are implemented by 
 * desugaring:  Abstract syntax is method calls. 
 */
expr:  expr '*' expr   { $$ = AST::Call::binop("TIMES", *$1, *$3); }
    |  expr '/' expr   { $$ = AST::Call::binop("DIV", *$1, *$3); }
    |  expr '+' expr   { $$ = AST::Call::binop("PLUS", *$1, *$3); }
    |  expr '-' expr   { $$ = AST::Call::binop("MINUS", *$1, *$3); }
    |  '-' expr  %prec NEG  {
                              auto zero = new AST::IntConst(0);
                              $$ = AST::Call::binop("MINUS", *zero, *$2);
                            }
    /* Comparisons */
    | expr EQUALS expr    { $$ = AST::Call::binop("EQUALS", *$1, *$3); }
    | expr ATLEAST expr   { $$ = AST::Call::binop("ATLEAST", *$1, *$3); }
    | expr '>' expr       { $$ = AST::Call::binop("GREATER", *$1, *$3);  }
    | expr ATMOST expr    { $$ = AST::Call::binop("ATMOST", *$1, *$3); }
    | expr '<' expr       { $$ = AST::Call::binop("LESS", *$1, *$3); }
    /* Boolean expressions are NOT syntactic sugar */
    | expr AND   expr     { $$ = new AST::And(*$1, *$3); }
    | expr OR    expr     { $$ = new AST::Or(*$1, *$3); }
    | NOT expr            { $$ = new AST::Not(*$2); }
    ;


/* Parentheses may be used to override associativity, 
 * or for clarity of expression. 
 */
expr: '(' expr ')' { $$ = $2; } ;



/* Method calls are indicated in the usual way 
 * as obj.method(args)
 * 
 * Precedence note:  
 *   a+b.c(i) is a+(b.c(i))
 *   a.b.c(i) is (a.b).c(i)
 * We make calls on an expr, not an lexpr --- 
 *   we need an actual value to look up the 
 *   method in.  The only exception is class 
 *   constructors ... but we can treat the
 *   class as an rvalue also. 
 * 
 */ 

expr: expr '.' ident '(' actual_args ')'
 { $$ = new AST::Call(*$1, *$3, *$5); }
 ;
actual_args: /*empty*/  { $$ = new AST::Actuals(); }
   | actual_args_nonempty { $$ = $1; };
actual_args_nonempty: 
            actual_args_nonempty ',' expr { $$ = $1; $$->append($3); }
          | expr  { $$ = new AST::Actuals(); $$->append($1); }
          ; 

/* Constructor calls */
expr: ident '(' actual_args ')'
   { $$ = new AST::Construct(*$1, *$3); }
   ;

ident: IDENT { $$ = new AST::Ident($1); } ;

%%

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}
