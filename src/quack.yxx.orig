
/* 
 * Quack, a simple language for beginning compiler writers
 * 
 */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree

}

%locations
  /* %define parse.trace --- can't do this and also --debug on command line */

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

/* -------------------------------------------------------
 * Semantic values: Tokens and Abstract Syntax Tree
 * -------------------------------------------------------
 */

%union {
    /* Tokens */
    int   num;
    char*  str;
    /* Abstract syntax tree values */
    AST::ASTNode* node;  // Most general class
    AST::Ident* ident;   // Identifiers are used in many places
    AST::LExpr* l_expr;
    AST::Load*  load;
    AST::Statement* statement;
    AST::Expr* expr;
    // Alas, looks like we need a member per sequence type
    AST::Actuals* actuals;
    AST::Block* block;
    AST::Classes* classes;
    AST::Type_Alternatives* type_alternatives;
}

/* -----------------------------------------
 * Associate non-terminals with classes in
 * the abstract syntax tree (AST)
 * ------------------------------------------
 */
%type <ident> ident
%type <l_expr> l_expr
%type <expr> expr
%type <statement> statement
%type <node> pgm
%type <classes> classes
%type <block> statements statement_block
%type <actuals> actual_args actual_args_nonempty
%type <block>  opt_elif_parts

/* -------------------------------------------
 * Tokens.
 * -------------------------------------------
 */
/* Keywords (no semantic values) */
%token CLASS
%token DEF
%token EXTENDS 
%token IF ELIF ELSE
%token WHILE
%token RETURN
%token TYPECASE

 /* Multi-character punctuation (no semantic values) */
%token ATLEAST ATMOST EQUALS
%token AND OR NOT 

/* Identifiers (semantic value is the identifier name) */
%type <str> IDENT
%token IDENT

/* Literals (semantic value is the literal value) */
%token INT_LIT STRING_LIT
%type <str> STRING_LIT
%type <num> INT_LIT


/* Precedence of arithmetic operators
 * and deref
 */

%left AND OR
%left NOT
%nonassoc ATMOST '>'
%nonassoc ATLEAST '<'
%left EQUALS
%left '+' '-'
%left '*' '/'
%precedence NEG   /* Negation */ 
%left '.'         /*  because a.b.c*d is ((a.b).c)*d */
%%

/* *************************************
 * Program Structure 
 * *************************************
 */ 

/* A Quack program is a sequence of classes followed by some 
 * statements.  The statements are the main program. 
 */

pgm:	classes  statements
        { $$ = new AST::Program(*$1, *$2);
          // std::cerr << "Transmitting root to driver\n";
          *root = $$; // Transmit tree back to driver
          // std::cerr << "Transmitted root to driver\n";
        }
        ;

/* Zero or more classes;
 *   starter code limits it to zero classes.
 */
classes:   /* empty */      {  $$ = new AST::Classes(); }
       ;

/* Zero or more statements 
 * (although a program with zero statements is pretty boring) 
 */
statements: statements statement  { $$ = $1;
                                    $$->append($2);
                                  }
          | /* empty */           { $$ = new AST::Block(); }
          ;


/* A block is demarcated by curly braces.   */
statement_block: '{' statements '}'
  {  $$ = $2; }
  ;

/* *************************************
 * Statements: Control structure
 * *************************************
 */ 

/* Conditional: 
 *   if x < 0 
 *     { x = x + 1; }
 *   elif x > 10
 *     { x = x - 3; }
 *   else
 *     { x = 0; }
 */ 

statement: IF expr statement_block  opt_elif_parts
	       { $$ = new AST::If(*$2, *$3, *$4); }
	     ;

opt_elif_parts:  ELIF expr statement_block  opt_elif_parts
             { $$ = new AST::Block();
               $$->append(new AST::If(*$2, *$3, *$4));
             }
             |   ELSE statement_block
             { $$ = $2; }
             | /* empty */
             { $$ = new AST::Block(); }
             ;



/* *************************************
 * Statements: Assignment
 * *************************************
 */ 


statement: l_expr '=' expr ';'
     { $$ = new AST::Assign(*$1, *$3); }
     ;

statement: l_expr ':' ident '=' expr ';'
    {
      $$ = new AST::AssignDeclare(*$1, *$5, *$3);
    }
    ;

/* l_expr: Things we can assign to, or call.
 * (Evaluate to a location; type checking determines
 * what type is compatible.)
 * Including: 
 *    Simple local variable assignments like x = expr; 
 *    Fields of the current object, this.x = expr; 
 *    Methods of any object, (3+4).PRINT, sqr.translate(1,1).translate
 */ 
l_expr: IDENT { $$ =  new AST::Ident($1); } ;


/* *************************************
 * Expressions 
 * (right-hand expressions, i.e., expressions
 *  that evaluate to values rather than locations)
 * *************************************
 */ 

/* An l_expr is also an expr; we load the value 
 * from that address.  Even though this is a unit production,
 * it corresponds to an operation (loading a value) in the
 * semantics, so we give it a node in the AST.
 */ 
expr: l_expr { $$ = new AST::Load(*$1); } ;

/* Values can also be denoted by literals */
expr: STRING_LIT { $$ = new AST::StrConst($1); }
    | INT_LIT    { $$ = new AST::IntConst($1); }
    ;

/* The binary operations.  We will use precedence 
 * rather than expanding out the expression grammar. 
 * We order by precedence and indicate associativity. 
 * 
 * Binary and unary operations are implemented by 
 * desugaring:  Abstract syntax is method calls. 
 */
expr:  expr '*' expr   { $$ = AST::Call::binop("TIMES", *$1, *$3); }
    |  expr '+' expr   { $$ = AST::Call::binop("PLUS", *$1, *$3); }
    |  expr '-' expr   { $$ = AST::Call::binop("MINUS", *$1, *$3); }
    |  '-' expr  %prec NEG  {
                              auto zero = new AST::IntConst(0);
                              $$ = AST::Call::binop("MINUS", *zero, *$2);
                            }
    /* Comparisons */
    /* Boolean expressions are NOT syntactic sugar */
    | expr AND   expr     { $$ = new AST::And(*$1, *$3); }
    ;



/* Method calls are indicated in the usual way 
 * as obj.method(args)
 * 
 * Precedence note:  
 *   a+b.c(i) is a+(b.c(i))
 *   a.b.c(i) is (a.b).c(i)
 * We make calls on an expr, not an lexpr --- 
 *   we need an actual value to look up the 
 *   method in.  The only exception is class 
 *   constructors ... but we can treat the
 *   class as an rvalue also. 
 * 
 */ 

expr: expr '.' ident '(' actual_args ')'
 { $$ = new AST::Call(*$1, *$3, *$5); }
 ;
actual_args: /*empty*/  { $$ = new AST::Actuals(); }
   | actual_args_nonempty { $$ = $1; };
actual_args_nonempty: 
            actual_args_nonempty ',' expr { $$ = $1; $$->append($3); }
          | expr  { $$ = new AST::Actuals(); $$->append($1); }
          ; 

/* Constructor calls */
expr: ident '(' actual_args ')'
   { $$ = new AST::Construct(*$1, *$3); }
   ;

ident: IDENT { $$ = new AST::Ident($1); } ;

%%

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}
