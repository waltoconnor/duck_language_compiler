%top{
/* Quack scanner
 *
 * 2019 Fall version for RE/flex
 * 
 */ 

#include "quack.tab.hxx"  /* Generated by bison. */
#include "Messages.h"
%}

%{
/* Externally visible file name --
* for error messages.
* FIXME: Need to extract this from structures that reflex passes
* or else find another way to dig it out.
*/
std::string yyfilename = "What file is this, anyway?";

/* Some strings can't be matched in one gulp.  We need
 * a buffer in which to assemble them from parts.
 */
std::string string_buf = "";

void yyerror (const std::string &msg, yy::position* where) {
     std::cout << where << ": " << msg;
}

/* Some long messages that don't fit well in the code below */

std::string BAD_ESC_MSG =
  "Illegal escape code; only \\\\, \\0, \\t, \\n, \\r, \\n are permitted";
std::string BAD_NL_STR =
  "Unclosed string?  Encountered newline in quoted string."; 

%}


%option bison-cc bison-locations noyywrap
%option namespace=yy lexer=Lexer lex=yylex

%x comment
%x tripleq
%x str

%%

  /* We start with some tokens that are not value-bearing,
   * i.e., the parser needs to know only which token was matched.
   */

  /* Multi-character punctuation with names */
==    { return parser::token::EQUALS; }
[<]=  { return parser::token::ATMOST; }
[>]=  { return parser::token::ATLEAST; }

   /* Single character punctuation.  Because a character
    * in C or C++ can be treated as an integer, Bison lets
    * us return a character as a token.
    * JFlex/Cup do not let you do this in Java.
    */
[-+*/:.{}=<>();,]  { return text()[0]; }

  /* Keywords are essentially another kind of punctuation,
   * but since they also match the identifier pattern, we
   * need to be sure we give their patterns *before* the
   * identifier pattern.  Most scanner generators work this
   * way, but WARNING for Python PLY users:  PLY prioritizes
   * by length of the regular expression!
   */

class  { return parser::token::CLASS; }
def    { return parser::token::DEF; }
extends { return parser::token::EXTENDS; }
if      { return parser::token::IF; }
elif    { return parser::token::ELIF; }
else    { return parser::token::ELSE; }
while   { return parser::token::WHILE; }
return  { return parser::token::RETURN; }
typecase { return parser::token::TYPECASE; }
and     { return parser::token::AND; }
or      { return parser::token::OR; }
not     { return parser::token::NOT; }

   /* The following tokens are value-bearing:
    * We pass a value back to the parser by copying
    * it into the yylval parameter.  The parser
    * expects string values for identifiers and
    * string literals in yylval.str.  It expects integer
    * values for integer literals in yylval.num.
    */

[a-zA-Z_][a-zA-Z0-9_]*   { yylval.str = strdup(text()); return parser::token::IDENT; }
[0-9]+                   { yylval.num = atoi(text()); return parser::token::INT_LIT; }

  /* Strings, single and triple-quoted */
\"   { string_buf = ""; start(str); }
<str>[^\n\t\\"]+   { string_buf += text(); }
<str>\\n  { string_buf += "\n"; }
<str>\\t  { string_buf += "\t"; } /* etc */
<str>\\.  { yyerror(BAD_ESC_MSG, new yy::position(&yyfilename, lineno(),columno())); }
<str>\n   { yyerror(BAD_NL_STR,  new yy::position(&yyfilename, lineno(),columno()) );
           start(INITIAL);
           yylval.str = strdup(string_buf.c_str());
           return parser::token::STRING_LIT;
          }
<str>\"  { start(INITIAL);
           yylval.str = strdup(string_buf.c_str());
           return parser::token::STRING_LIT;
         }



  /* Triple-quoted strings.  Not all in one gulp.
   * When we see """, we enter an exclusive state in which
   * anything other than """ is added to a buffer.  Only
   * another """ breaks us out of that state.
   */
["]["]["]        { start(tripleq);  string_buf = ""; }

   /* The following pattern is basically zero or more occurrences of
    *    - Anything that isn't a quote
    *    - Or one quote followed by something else
    *    - Or two quotes followed by something else
    */
<tripleq>(([^"])|(["][^"])|(["]["][^"])|\n)*  {
    string_buf += text();
    }

    /* When we get the ending triple-quote, we return the
     * assembled buffer.
     */
<tripleq>["]["]["]  {
    yylval.str = strdup(string_buf.c_str());
    start(INITIAL);
    return parser::token::STRING_LIT;
    }


  /* Ignore whitespace */
[ \t\n]*  { ; }

   /* Multi-line comments */ 
[/][*]  { start(comment); }
<comment>[^*]*   { ; }
<comment>[*][^/] { ; }
<comment>[*][/]  { start(INITIAL); }

   /* Line end comments */
[/][/].*  { ; }

.  { yyerror("*** Unexpected character in line",
        new yy::position(&yyfilename, lineno(),columno())); }




<<EOF>>  { return EOF; }

%%

/* No main program here */ 

