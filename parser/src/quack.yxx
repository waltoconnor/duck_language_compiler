/* 
 * Quack, a simple language for beginning compiler writers
 * 
 */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree

}

%locations
  /* %define parse.trace --- can't do this and also --debug on command line */

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

/* -------------------------------------------------------
 * Semantic values: Tokens and Abstract Syntax Tree
 * -------------------------------------------------------
 */

%union {
    /* Tokens */
    int   num;
    char*  str;
    /* Abstract syntax tree values */
    AST::ASTNode* node;  // Most general class
    AST::Ident* ident;   // Identifiers are used in many places
    AST::LExpr* l_expr;
    AST::Load*  load;
    AST::Statement* statement;
    AST::Expr* expr;
    AST::Class* ast_class; //class is a reserved word
    AST::Method* method;
    // Alas, looks like we need a member per sequence type
    AST::Actuals* actuals;
    AST::Block* block;
    AST::Classes* classes;
    AST::Type_Alternatives* type_alternatives;
    AST::Formals* formals;
    AST::Methods* methods;
    AST::Formal* formal;
    AST::Formals* formals_not_empty;
    AST::Dot* dot;
    AST::Type_Alternative* type_alternative;

}

/* -----------------------------------------
 * Associate non-terminals with classes in
 * the abstract syntax tree (AST)
 * ------------------------------------------
 */
%type <ident> ident
%type <l_expr> l_expr
%type <expr> expr
%type <statement> statement
%type <node> pgm
%type <classes> classes
%type <block> statements statement_block
%type <actuals> actual_args actual_args_nonempty
%type <block>  opt_elif_parts
%type <ast_class> ast_class
%type <method> method
%type <formals> formals
%type <formal> formal
%type <methods> methods
%type <dot> dot
%type <type_alternatives> type_alternatives
%type <type_alternative> type_alternative
%type <formals_not_empty> formals_not_empty

/* -------------------------------------------
 * Tokens.
 * -------------------------------------------
 */
/* Keywords (no semantic values) */
%token CLASS
%token DEF
%token EXTENDS 
%token IF ELIF ELSE
%token WHILE
%token RETURN
%token TYPECASE

 /* Multi-character punctuation (no semantic values) */
%token ATLEAST ATMOST EQUALS
%token AND OR NOT 

/* Identifiers (semantic value is the identifier name) */
%type <str> IDENT
%token IDENT

/* Literals (semantic value is the literal value) */
%token INT_LIT STRING_LIT
%type <str> STRING_LIT
%type <num> INT_LIT


/* Precedence of arithmetic operators
 * and deref
 */

%left AND OR
%left NOT
%nonassoc ATMOST '>'
%nonassoc ATLEAST '<'
%left EQUALS
%left '+' '-'
%left '*' '/'
%precedence NEG   /* Negation */ 
%left '.'         /*  because a.b.c*d is ((a.b).c)*d */
%%

/* *************************************
 * Program Structure 
 * *************************************
 */ 

/* A Quack program is a sequence of classes followed by some 
 * statements.  The statements are the main program. 
 */

pgm:  classes  statements
        { $$ = new AST::Program(*$1, *$2);
          // std::cerr << "Transmitting root to driver\n";
          *root = $$; // Transmit tree back to driver
          // std::cerr << "Transmitted root to driver\n";
        }
        ;

/* Zero or more classes;
 *   starter code limits it to zero classes.
 */
classes: /* empty */          {  $$ = new AST::Classes(); }
       | classes ast_class    {  $$ = $1; $$->append($2); }  
       ;

//this is ugly and the constructor doesn't appear on the AST
ast_class: CLASS ident '(' formals ')' EXTENDS ident '{' statements methods '}' {
              AST::Method* constructor_method = new AST::Method(*$2, *$4,  *$2, *$9);
              AST::ASTNode* constructor_node = constructor_method;
              $$ = new AST::Class(*$2, *$7, *constructor_node , *$10);  
            }
          |CLASS ident '(' formals ')' '{' statements methods '}' {
              AST::Method* constructor_method = new AST::Method(*$2, *$4, *$2, *$7);
              AST::ASTNode* constructor_node = constructor_method;
              AST::Ident* obj_name = new AST::Ident("Obj");
              $$ = new AST::Class(*$2, *obj_name , *constructor_node, *$8);
          }
          ;

/*methods: methods method { $$=$1; $1->append($2); }
        | method { $$ = new AST::Methods(); $$->append($1); }
        | {$$ = new AST::Methods(); }
        ;
*/

methods: { $$ = new AST::Methods(); }
        | methods method { $$ = $1; $$->append($2); }
        ;

method: DEF ident '(' formals ')' ':' ident statement_block { $$ = new AST::Method(*$2, *$4, *$7, *$8); }
      | DEF ident '(' formals ')' statement_block { 
          AST::Ident* nothing = new AST::Ident("Nothing");
          $$ = new AST::Method(*$2, *$4, *nothing, *$6); 
      }
      ;

formal: ident ':' ident { $$ = new AST::Formal(*$1, *$3); };

/*formals: formals ',' formal { $$=$1; $$->append($3); }
        | formal { $$ = new AST::Formals(); $$->append($1); }
        | {$$ = new AST::Formals(); }
        ;*/

formals: { $$ = new AST::Formals(); }
        | formals_not_empty { $$ = $1; }
        ;

formals_not_empty: formal { $$ = new AST::Formals(); $$->append($1); }
                  |formals_not_empty ',' formal { $$ = $1; $$->append($3); }
                  ;



dot: expr '.' ident { $$ = new AST::Dot(*$1, *$3); };

statement: RETURN expr ';' { $$ = new AST::Return(*$2); }
          |RETURN ';' { $$ = new AST::Return(*new AST::Ident("none")); }
          ;

statement: TYPECASE expr '{' type_alternatives '}' { $$ = new AST::Typecase(*$2, *$4); };

type_alternative: ident ':' ident statement_block { $$ = new AST::Type_Alternative(*$1, *$3, *$4); };

type_alternatives: { $$ = new AST::Type_Alternatives(); }
                | type_alternatives type_alternative { $$ = $1; $1->append($2); }
                ; 

//handle side effect only
statement: expr ';' { $$ = $1; };


/* Zero or more statements 
 * (although a program with zero statements is pretty boring) 
 */
statements: statements statement  { $$ = $1;
                                    $$->append($2);
                                  }
          | /* empty */           { $$ = new AST::Block(); }
          ;


/* A block is demarcated by curly braces.   */
statement_block: '{' statements '}'
  {  $$ = $2; }
  ;

/* *************************************
 * Statements: Control structure
 * *************************************
 */ 

/* Conditional: 
 *   if x < 0 
 *     { x = x + 1; }
 *   elif x > 10
 *     { x = x - 3; }
 *   else
 *     { x = 0; }
 */ 

statement: IF expr statement_block  opt_elif_parts
         { $$ = new AST::If(*$2, *$3, *$4); }
       ;

opt_elif_parts:  ELIF expr statement_block  opt_elif_parts
             { $$ = new AST::Block();
               $$->append(new AST::If(*$2, *$3, *$4));
             }
             |   ELSE statement_block
             { $$ = $2; }
             | /* empty */
             { $$ = new AST::Block(); }
             ;

statement: WHILE '(' expr ')' statement_block { $$ = new AST::While(*$3, *$5); };

/* *************************************
 * Statements: Assignment
 * *************************************
 */ 


statement: l_expr '=' expr ';'
     { $$ = new AST::Assign(*$1, *$3); }
     ;

statement: l_expr ':' ident '=' expr ';'
    {
      $$ = new AST::AssignDeclare(*$1, *$5, *$3);
    }
    ;

/* l_expr: Things we can assign to, or call.
 * (Evaluate to a location; type checking determines
 * what type is compatible.)
 * Including: 
 *    Simple local variable assignments like x = expr; 
 *    Fields of the current object, this.x = expr; 
 *    Methods of any object, (3+4).PRINT, sqr.translate(1,1).translate
 */ 
l_expr: IDENT { $$ =  new AST::Ident($1); } 
      | dot  { $$ = $1; }
      ;


/* *************************************
 * Expressions 
 * (right-hand expressions, i.e., expressions
 *  that evaluate to values rather than locations)
 * *************************************
 */ 

/* An l_expr is also an expr; we load the value 
 * from that address.  Even though this is a unit production,
 * it corresponds to an operation (loading a value) in the
 * semantics, so we give it a node in the AST.
 */ 
expr: l_expr { $$ = new AST::Load(*$1); } ;

/* Values can also be denoted by literals */
expr: STRING_LIT { $$ = new AST::StrConst($1); }
    | INT_LIT    { $$ = new AST::IntConst($1); }
    ;

/* The binary operations.  We will use precedence 
 * rather than expanding out the expression grammar. 
 * We order by precedence and indicate associativity. 
 * 
 * Binary and unary operations are implemented by 
 * desugaring:  Abstract syntax is method calls. 
 */
expr:  expr '*' expr   { $$ = AST::Call::binop("TIMES", *$1, *$3); }
    |  expr '+' expr   { $$ = AST::Call::binop("PLUS", *$1, *$3); }
    |  expr '-' expr   { $$ = AST::Call::binop("MINUS", *$1, *$3); }
    |  '-' expr  %prec NEG  {
                              auto zero = new AST::IntConst(0);
                              $$ = AST::Call::binop("MINUS", *zero, *$2);
                            }
    /* Comparisons */
    /* Boolean expressions are NOT syntactic sugar */
    | expr AND   expr     { $$ = new AST::And(*$1, *$3); }
    | expr OR    expr     { $$ = new AST::Or(*$1, *$3);  }
    | NOT expr            { $$ = new AST::Not(*$2);      }
    | expr '>'   expr     { $$ = new AST::More(*$1, *$3); }
    | expr '<'   expr     { $$ = new AST::Less(*$1, *$3); }
    | expr ATMOST   expr  { $$ = new AST::Atmost(*$1, *$3); }
    | expr ATLEAST  expr  { $$ = new AST::Atleast(*$1, *$3); }
    | expr EQUALS   expr  { $$ = new AST::Equals(*$1, *$3); }
    ;



/* Method calls are indicated in the usual way 
 * as obj.method(args)
 * 
 * Precedence note:  
 *   a+b.c(i) is a+(b.c(i))
 *   a.b.c(i) is (a.b).c(i)
 * We make calls on an expr, not an lexpr --- 
 *   we need an actual value to look up the 
 *   method in.  The only exception is class 
 *   constructors ... but we can treat the
 *   class as an rvalue also. 
 * 
 */ 

expr: expr '.' ident '(' actual_args ')'
 { $$ = new AST::Call(*$1, *$3, *$5); }
 ;
actual_args: /*empty*/  { $$ = new AST::Actuals(); }
   | actual_args_nonempty { $$ = $1; };
actual_args_nonempty: 
            actual_args_nonempty ',' expr { $$ = $1; $$->append($3); }
          | expr  { $$ = new AST::Actuals(); $$->append($1); }
          ; 

/* Constructor calls */
expr: ident '(' actual_args ')'
   { $$ = new AST::Construct(*$1, *$3); }
   ;

ident: IDENT { $$ = new AST::Ident($1); } ;

%%

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}